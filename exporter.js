// ===== 激光切割导出：把当前机制的连杆转成 SVG 药丸形外轮廓 + 两端孔 =====

function exportLinksToSVG(){
  const mech = window.curvedScissorMechanism;
  mech.update();

  // 读取参数
  const linkWidth = +document.getElementById('lc_linkWidth').value;   // mm
  const holeDia   = +document.getElementById('lc_holeDia').value;     // mm
  const tol       = +document.getElementById('lc_groupTol').value;    // mm
  const spacing   = +document.getElementById('lc_spacing').value;     // mm
  const px2mm     = +document.getElementById('lc_px2mm').value;       // mm/px
  const strokeW   = +document.getElementById('lc_strokeW').value;     // mm
  const kerf      = +document.getElementById('lc_kerf').value;        // mm（简补）
  const perRow    = Math.max(1, (+document.getElementById('lc_perRow').value|0));

  // 简易 kerf 处理：外形宽度 += kerf；孔径 += kerf
  const bodyW = Math.max(0.1, linkWidth + kerf);
  const holeD = Math.max(0.1, holeDia + kerf);

  // 收集所有连杆（类型 a/b 都算），以孔心距为长度
  const allLinks = [];
  for(const lk of mech.links){
    if(!(lk.start && lk.end)) continue;
    const Lpx = Math.hypot(lk.end.x - lk.start.x, lk.end.y - lk.start.y);
    const Lmm = Lpx * px2mm;
    const mid = { x: (lk.start.x + lk.end.x)/2, y: (lk.start.y + lk.end.y)/2 };
    const ang = Math.atan2(lk.end.y - lk.start.y, lk.end.x - lk.start.x);
    allLinks.push({ Lmm, mid, ang, start: lk.start, end: lk.end, id: lk.id });
  }

  if(allLinks.length === 0){
    alert('没有可导出的连杆。');
    return;
  }

  // 按长度分组（容差 tol）
  const groups = new Map(); // key: rounded length, value: {Lmm, items:[]}
  const roundTo = (x, step) => Math.round(x/step)*step;
  for(const item of allLinks){
    const key = roundTo(item.Lmm, tol).toFixed(3);
    if(!groups.has(key)) groups.set(key, { Lmm: +key, items: [] });
    groups.get(key).items.push(item);
  }

  // 平铺布局：每件水平放置，行内间距 spacing，行距 = max(bodyW, holeD)+spacing
  const keys = Array.from(groups.keys()).sort((a,b)=>parseFloat(a)-parseFloat(b));
  const margin = spacing;
  const rowGap = bodyW + spacing;
  let x = margin, y = margin, col = 0, maxRowW = 0;
  const place = []; // {x,y,Lmm, count, indexInGroup}
  const stats = [];

  for(const k of keys){
    const g = groups.get(k);
    stats.push({ len: g.Lmm, count: g.items.length });
    for(let i=0;i<g.items.length;i++){
      const L = g.Lmm;
      place.push({ x, y, Lmm: L, idx: i, group: k });
      // 更新游标
      x += L + spacing + bodyW; // 外形长度 + 间距（多加 bodyW 让孔位也留边）
      col++;
      maxRowW = Math.max(maxRowW, x);
      if(col >= perRow){
        col = 0; x = margin; y += rowGap + bodyW; // 新行
      }
    }
    // 换一行分隔不同长度组（如果上一行未正好换行）
    if(col !== 0){ col = 0; x = margin; y += rowGap + bodyW; }
  }

  const widthMM  = Math.max(maxRowW, perRow*(spacing+bodyW)) + margin;
  const heightMM = y + margin + bodyW;

  // 生成 SVG 字符串
  const svgParts = [];
  svgParts.push(`<?xml version="1.0" encoding="UTF-8"?>`);
  svgParts.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${widthMM}mm" height="${heightMM}mm" viewBox="0 0 ${widthMM} ${heightMM}" version="1.1">`);
  svgParts.push(`<desc>Generated by Curved Scissor Mechanism · linkWidth=${linkWidth}mm, hole=${holeDia}mm, tol=${tol}mm, px2mm=${px2mm}mm/px, kerf=${kerf}mm</desc>`);
  svgParts.push(`<g fill="none" stroke="#ff0000" stroke-width="${strokeW}" stroke-linecap="round" stroke-linejoin="round">`);

  // 一个“药丸形”外轮廓 + 两端孔
  const capsulePath = (cx, cy, L, W) => {
    const r = W/2;
    const x1 = cx - L/2, x2 = cx + L/2;
    const y1 = cy - r,   y2 = cy + r;
    // 路径沿水平坐标构建
    return `M ${x1} ${y1} H ${x2} A ${r} ${r} 0 0 1 ${x2} ${y2} H ${x1} A ${r} ${r} 0 0 1 ${x1} ${y1} Z`;
  };

  // 绘制所有件（水平摆放）
  for(const p of place){
    const cx = p.x + p.Lmm/2;  // 左上角起算，居中到外形
    const cy = p.y + bodyW/2;

    // 外形
    svgParts.push(`<path d="${capsulePath(cx, cy, p.Lmm, bodyW)}"/>`);

    // 两端孔（注意孔为单独圆，切割同色）
    const r = holeD/2;
    const hx1 = cx - p.Lmm/2, hx2 = cx + p.Lmm/2, hy = cy;
    svgParts.push(`<circle cx="${hx1}" cy="${hy}" r="${r}"/>`);
    svgParts.push(`<circle cx="${hx2}" cy="${hy}" r="${r}"/>`);
  }

  svgParts.push(`</g>`);

  // 角落打印统计（可作为轻微雕刻；若你的机型按颜色区分切/刻，请换色）
  svgParts.push(`<g fill="none" stroke="#00a0ff" stroke-width="${Math.max(0.05, strokeW/2)}">`);
  let ty = Math.min(12, heightMM - 6);
  svgParts.push(`<text x="4" y="${ty}" font-size="4" fill="#00a0ff">Groups: ${stats.map(s=>`${s.len.toFixed(2)}mm ×${s.count}`).join('  |  ')}</text>`);
  svgParts.push(`</g>`);

  svgParts.push(`</svg>`);
  const svg = svgParts.join('\n');

  // 触发下载
  const blob = new Blob([svg], {type: 'image/svg+xml;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.download = `scissor_links_${ts}.svg`;
  a.href = url;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
